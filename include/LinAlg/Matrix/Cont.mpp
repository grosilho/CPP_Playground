module;
#include <experimental/mdspan>
#include <memory>

export module LinAlg.Matrix.Cont;

namespace LinAlg
{
    namespace stdex = std::experimental;

    template <typename T, typename Cont>
    class Matrix;
}

export namespace LinAlg
{
    template <typename T>
    class Array2D;

    template <typename T>
    void swap(Array2D<T>& lhs, Array2D<T>& rhs) noexcept;

    template <typename T>
    class Array2D
    {

      public:
        Array2D(int rows, int cols);
        Array2D(const Array2D& other);
        Array2D(Array2D&& other) noexcept;
        ~Array2D() = default;

        Array2D& operator=(Array2D other) noexcept;

        friend void swap<T>(Array2D<T>& lhs, Array2D<T>& rhs) noexcept;
        friend class Matrix<T, Array2D<T>>;

        T& operator[](int i, int j);      ///< Access the element at row i and column j.
        T operator[](int i, int j) const; ///< Access the element at row i and column j.

        int rows() const;
        int cols() const;

      private:
        int m_rows;
        int m_cols;
        std::unique_ptr<T[]> m_data;
        stdex::mdspan<T, stdex::dextents<int, 2>> m_matrix;
    };
}

namespace LinAlg
{
    template <typename T>
    Array2D<T>::Array2D(int rows, int cols)
        : m_rows { rows }
        , m_cols { cols }
        , m_data { rows * cols > 0 ? std::make_unique<T[]>(rows * cols) : nullptr }
    {
        if (m_data)
            m_matrix = stdex::mdspan<T, stdex::dextents<int, 2>>(m_data.get(), rows, cols);
    }

    template <typename T>
    Array2D<T>::Array2D(const Array2D& other)
        : Array2D(other.m_rows, other.m_cols)
    {
        if (m_data)
            std::copy_n(other.m_data.get(), m_rows * m_cols, m_data.get());
    }

    template <typename T>
    Array2D<T>::Array2D(Array2D&& other) noexcept
        : Array2D(0, 0)
    {
        swap(*this, other);
    }

    template <typename T>
    Array2D<T>& Array2D<T>::operator=(Array2D other) noexcept
    {
        swap(*this, other);
        return *this;
    }

    template <typename T>
    void swap(Array2D<T>& lhs, Array2D<T>& rhs) noexcept
    {
        using std::swap;
        swap(lhs.m_rows, rhs.m_rows);
        swap(lhs.m_cols, rhs.m_cols);
        swap(lhs.m_data, rhs.m_data);
        swap(lhs.m_matrix, rhs.m_matrix);
    }

    template <typename T>
    T& Array2D<T>::operator[](int i, int j)
    {
        return m_matrix[i, j];
    }

    template <typename T>
    T Array2D<T>::operator[](int i, int j) const
    {
        return m_matrix[i, j];
    }

    template <typename T>
    int Array2D<T>::rows() const
    {
        return m_rows;
    }

    template <typename T>
    int Array2D<T>::cols() const
    {
        return m_cols;
    }
}
