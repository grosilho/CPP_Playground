module;

#include <utility>

export module LinAlg.Matrix;

export namespace LinAlg
{
    template <typename T>
    class Matrix;

    template <typename T>
    struct traits;

    template <typename T>
    struct traits<Matrix<T>>
    {
        using Scalar = T;
    };

    // template <typename T, typename Derived>
    // void swap(MatrixBase<T, Derived>& lhs, MatrixBase<T, Derived>& rhs) noexcept;

    template <typename Derived>
    class MatrixBase
    {
      public:
        using Scalar = traits<Derived>::Scalar;

        MatrixBase(int rows, int cols);
        // MatrixBase(const MatrixBase& other);
        // MatrixBase(MatrixBase&& other) noexcept;
        ~MatrixBase() = default;

        // friend void swap<T, Derived>(MatrixBase& lhs, MatrixBase& rhs) noexcept;

        // MatrixBase& operator=(MatrixBase other) noexcept;

        // std::pair<int, int> size() const; ///< Returns the number of rows and columns.
        // int cols() const;                 ///< Returns the number of columns.
        // int rows() const;                 ///< Returns the number of rows.

        // T& operator[](int i, int j);      ///< Access the element at row i and column j.
        // T operator[](int i, int j) const; ///< Access the element at row i and column j.

        // static MatrixBase<T, Derived> Zero(int n, int m); ///< Returns the zero MatrixBase of size n times m.
        // static MatrixBase<T, Derived> Identity(int n);    ///< Returns the identity MatrixBase of size n.

      private:
        int m_rows;
        int m_cols;
    };

    template <typename T>
    class Matrix : public MatrixBase<Matrix<T>>
    {
      public:
        using MatrixBase<Matrix<T>>::MatrixBase;
    };

} // namespace LinAlg

// private is not implemented in GCC yet.
// module :private;

namespace LinAlg
{
    /**
     * @brief Construct a new MatrixBase given the number of rows and columns.
     *
     * Allocates memory but does not initialize it.
     *
     * @param rows
     * @param cols
     */
    template <typename Derived>
    MatrixBase<Derived>::MatrixBase(int rows, int cols)
        : m_rows { rows }
        , m_cols { cols }
    {
    }

    // template <typename T, typename Cont>
    // MatrixBase<T, Cont>::MatrixBase(const MatrixBase& other)
    //     : m_rows { other.m_rows }
    //     , m_cols { other.m_cols }
    //     , m_MatrixBase { other.m_MatrixBase }
    // {
    // }

    // template <typename T, typename Cont>
    // MatrixBase<T, Cont>::MatrixBase(MatrixBase&& other) noexcept
    //     : MatrixBase(0, 0)
    // {
    //     swap(*this, other);
    // }

    // template <typename T, typename Cont>
    // void swap(MatrixBase<T, Cont>& lhs, MatrixBase<T, Cont>& rhs) noexcept
    // {
    //     using std::swap;
    //     swap(lhs.m_rows, rhs.m_rows);
    //     swap(lhs.m_cols, rhs.m_cols);
    //     swap(lhs.m_MatrixBase, rhs.m_MatrixBase);
    // }

    // template <typename T, typename Cont>
    // MatrixBase<T, Cont>& MatrixBase<T, Cont>::operator=(MatrixBase other) noexcept
    // {
    //     swap(*this, other);
    //     return *this;
    // }

    // template <typename T, typename Cont>
    // std::pair<int, int> MatrixBase<T, Cont>::size() const
    // {
    //     return std::make_pair(m_rows, m_cols);
    // }

    // template <typename T, typename Cont>
    // int MatrixBase<T, Cont>::cols() const
    // {
    //     return m_cols;
    // }

    // template <typename T, typename Cont>
    // int MatrixBase<T, Cont>::rows() const
    // {
    //     return m_rows;
    // }

    // template <typename T, typename Cont>
    // T& MatrixBase<T, Cont>::operator[](int i, int j)
    // {
    //     return m_MatrixBase[i, j];
    // }

    // template <typename T, typename Cont>
    // T MatrixBase<T, Cont>::operator[](int i, int j) const
    // {
    //     return m_MatrixBase[i, j];
    // }

    // template <typename T, typename Cont>
    // MatrixBase<T, Cont> MatrixBase<T, Cont>::Zero(int n, int m)
    // {
    //     MatrixBase<T, Cont> zero(n, m);
    //     for (int i = 0; i < n; ++i)
    //         for (int j = 0; j < m; ++j)
    //             zero[i, j] = 0;
    //     return zero;
    // }

    // template <typename T, typename Cont>
    // MatrixBase<T, Cont> MatrixBase<T, Cont>::Identity(int n)
    // {
    //     MatrixBase<T, Cont> identity(n, n);
    //     for (int i = 0; i < n; ++i)
    //         for (int j = 0; j < n; ++j)
    //             identity[i, j] = static_cast<T>(i == j);
    //     return identity;
    // }

} // namespace LinAlg
