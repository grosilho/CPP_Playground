module;

#include <utility>

export module LinAlg.Matrix;

import LinAlg.Matrix.Cont;

export namespace LinAlg
{
    template <typename T, typename Cont>
    class Matrix;

    template <typename T, typename Cont>
    void swap(Matrix<T, Cont>& lhs, Matrix<T, Cont>& rhs) noexcept;

    template <typename T, typename Cont = Array2D<T>>
    class Matrix
    {
    public:
        Matrix(int rows, int cols);
        Matrix(const Matrix& other);
        Matrix(Matrix&& other) noexcept;
        ~Matrix();

        friend void swap<T, Cont>(Matrix& lhs, Matrix& rhs) noexcept;

        Matrix& operator=(Matrix other) noexcept;

        std::pair<int, int> size() const; ///< Returns the number of rows and columns.
        int cols() const;                 ///< Returns the number of columns.
        int rows() const;                 ///< Returns the number of rows.

        T& operator[](int i, int j);      ///< Access the element at row i and column j.
        T operator[](int i, int j) const; ///< Access the element at row i and column j.

        static Matrix<T, Cont> Zero(int n, int m); ///< Returns the zero matrix of size n times m.
        static Matrix<T, Cont> Identity(int n);    ///< Returns the identity matrix of size n.

    private:
        int m_rows;
        int m_cols;
        Cont m_matrix;
    };

} // namespace LinAlg

// private is not implemented in GCC yet.
// module :private;

namespace LinAlg
{
    /**
     * @brief Construct a new Matrix given the number of rows and columns.
     *
     * Allocates memory but does not initialize it.
     *
     * @param rows
     * @param cols
     */
    template <typename T, typename Cont>
    Matrix<T, Cont>::Matrix(int rows, int cols)
        : m_rows { rows }
        , m_cols { cols }
        , m_matrix { rows, cols }
    {
    }

    template <typename T, typename Cont>
    Matrix<T, Cont>::Matrix(const Matrix& other)
        : m_rows { other.m_rows }
        , m_cols { other.m_cols }
        , m_matrix { other.m_matrix }
    {
    }

    template <typename T, typename Cont>
    Matrix<T, Cont>::Matrix(Matrix&& other) noexcept
        : Matrix(0, 0)
    {
        swap(*this, other);
    }

    template <typename T, typename Cont>
    Matrix<T, Cont>::~Matrix() = default;

    template <typename T, typename Cont>
    void swap(Matrix<T, Cont>& lhs, Matrix<T, Cont>& rhs) noexcept
    {
        using std::swap;
        swap(lhs.m_rows, rhs.m_rows);
        swap(lhs.m_cols, rhs.m_cols);
        swap(lhs.m_matrix, rhs.m_matrix);
    }

    template <typename T, typename Cont>
    Matrix<T, Cont>& Matrix<T, Cont>::operator=(Matrix other) noexcept
    {
        swap(*this, other);
        return *this;
    }

    template <typename T, typename Cont>
    std::pair<int, int> Matrix<T, Cont>::size() const
    {
        return std::make_pair(m_rows, m_cols);
    }

    template <typename T, typename Cont>
    int Matrix<T, Cont>::cols() const
    {
        return m_cols;
    }

    template <typename T, typename Cont>
    int Matrix<T, Cont>::rows() const
    {
        return m_rows;
    }

    template <typename T, typename Cont>
    T& Matrix<T, Cont>::operator[](int i, int j)
    {
        return m_matrix[i, j];
    }

    template <typename T, typename Cont>
    T Matrix<T, Cont>::operator[](int i, int j) const
    {
        return m_matrix[i, j];
    }

    template <typename T, typename Cont>
    Matrix<T, Cont> Matrix<T, Cont>::Zero(int n, int m)
    {
        Matrix<T, Cont> zero(n, m);
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                zero[i, j] = 0;
        return zero;
    }

    template <typename T, typename Cont>
    Matrix<T, Cont> Matrix<T, Cont>::Identity(int n)
    {
        Matrix<T, Cont> identity(n, n);
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                identity[i, j] = static_cast<T>(i == j);
        return identity;
    }

} // namespace LinAlg
