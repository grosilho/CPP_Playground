module;

#include <experimental/mdspan>
#include <memory>
#include <utility>

export module LinAlg.Matrix;

export namespace LinAlg
{

    namespace stdex = std::experimental;

    template <typename T> class Matrix
    {
      public:
        Matrix (int rows, int cols);
        ~Matrix ();

        std::pair<std::size_t, std::size_t> size () const; ///< Returns the number of rows and columns.
        std::size_t cols () const;                         ///< Returns the number of columns.
        std::size_t rows () const;                         ///< Returns the number of rows.

      private:
        std::size_t m_rows;
        std::size_t m_cols;
        std::unique_ptr<T> m_data;
        stdex::mdspan<T, stdex::dextents<int, 2> > m_matrix;
    };

}

// private is not implemented in GCC yet.
// module :private;

namespace LinAlg
{
    /**
     * @brief Construct a new Matrix given the number of rows and columns.
     *
     * Allocates memory but does not initialize it.
     *
     * @param rows
     * @param cols
     */
    template <typename T> Matrix<T>::Matrix (int rows, int cols)
        : m_rows (rows), m_cols (cols), m_data (std::make_unique<T> (rows * cols))
    {
        m_matrix = stdex::mdspan<T, stdex::dextents<int, 2> > (m_data.get (), rows, cols);
    }

    template <typename T> Matrix<T>::~Matrix () = default;

    template <typename T> std::pair<std::size_t, std::size_t>
    Matrix<T>::size () const
    {
        return std::make_pair (m_rows, m_cols);
    }

    template <typename T> std::size_t
    Matrix<T>::cols () const
    {
        return m_cols;
    }

    template <typename T> std::size_t
    Matrix<T>::rows () const
    {
        return m_rows;
    }

}
